<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ceph源码分析:BackoffThrottle及问题</title>
      <link href="/2018/04/28/ceph_backoffThrottle_config/"/>
      <url>/2018/04/28/ceph_backoffThrottle_config/</url>
      <content type="html"><![CDATA[<h2 id="BackoffThrottle简介"><a href="#BackoffThrottle简介" class="headerlink" title="BackoffThrottle简介"></a>BackoffThrottle简介</h2><p>J版本进入新的流控方式BackoffThrottle， filesttore和journal都使用这个</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>journal 流控设置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FileJournal::set_throttle_params()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">bool</span> valid = throttle.set_params(</span><br><span class="line">    g_conf-&gt;journal_throttle_low_threshhold,</span><br><span class="line">    g_conf-&gt;journal_throttle_high_threshhold,</span><br><span class="line">    g_conf-&gt;filestore_expected_throughput_bytes,</span><br><span class="line">    g_conf-&gt;journal_throttle_high_multiple,</span><br><span class="line">    g_conf-&gt;journal_throttle_max_multiple,</span><br><span class="line">    header.max_size - get_top(),</span><br><span class="line">    &amp;ss);</span><br></pre></td></tr></table></figure></p><p>filestore 流控设置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FileStore::set_throttle_params()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">bool</span> valid = throttle_bytes.set_params(</span><br><span class="line">    g_conf-&gt;filestore_queue_low_threshhold,</span><br><span class="line">    g_conf-&gt;filestore_queue_high_threshhold,</span><br><span class="line">    g_conf-&gt;filestore_expected_throughput_bytes,</span><br><span class="line">    g_conf-&gt;filestore_queue_high_delay_multiple,</span><br><span class="line">    g_conf-&gt;filestore_queue_max_delay_multiple,</span><br><span class="line">    g_conf-&gt;filestore_queue_max_bytes,</span><br><span class="line">    &amp;ss);</span><br><span class="line"></span><br><span class="line">  valid &amp;= throttle_ops.set_params(</span><br><span class="line">    g_conf-&gt;filestore_queue_low_threshhold,</span><br><span class="line">    g_conf-&gt;filestore_queue_high_threshhold,</span><br><span class="line">    g_conf-&gt;filestore_expected_throughput_ops,</span><br><span class="line">    g_conf-&gt;filestore_queue_high_delay_multiple,</span><br><span class="line">    g_conf-&gt;filestore_queue_max_delay_multiple,</span><br><span class="line">    g_conf-&gt;filestore_queue_max_ops,</span><br><span class="line">    &amp;ss);</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算延时比率</span></span><br><span class="line"><span class="keyword">bool</span> BackoffThrottle::set_params(</span><br><span class="line">  <span class="keyword">double</span> _low_threshhold,</span><br><span class="line">  <span class="keyword">double</span> _high_threshhold,</span><br><span class="line">  <span class="keyword">double</span> _expected_throughput,</span><br><span class="line">  <span class="keyword">double</span> _high_multiple,</span><br><span class="line">  <span class="keyword">double</span> _max_multiple,</span><br><span class="line">  <span class="keyword">uint64_t</span> _throttle_max,</span><br><span class="line">  ostream *errstream)</span><br><span class="line">...</span><br><span class="line">  low_threshhold = _low_threshhold;</span><br><span class="line">  high_threshhold = _high_threshhold;</span><br><span class="line">  high_delay_per_count = _high_multiple / _expected_throughput;</span><br><span class="line">  max_delay_per_count = _max_multiple / _expected_throughput;</span><br><span class="line">  max = _throttle_max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (high_threshhold - low_threshhold &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s0 = high_delay_per_count / (high_threshhold - low_threshhold);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    low_threshhold = high_threshhold;</span><br><span class="line">    s0 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> - high_threshhold &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s1 = (max_delay_per_count - high_delay_per_count)</span><br><span class="line">      / (<span class="number">1</span> - high_threshhold);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    high_threshhold = <span class="number">1</span>;</span><br><span class="line">    s1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 计算delay时间</span></span><br><span class="line"><span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; BackoffThrottle::_get_delay(<span class="keyword">uint64_t</span> c) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (max == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> r = ((<span class="keyword">double</span>)current) / ((<span class="keyword">double</span>)max);</span><br><span class="line">  <span class="keyword">if</span> (r &lt; low_threshhold) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; high_threshhold) &#123;</span><br><span class="line">    <span class="keyword">return</span> c * <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(</span><br><span class="line">      (r - low_threshhold) * s0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c * <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(</span><br><span class="line">      high_delay_per_count + ((r - high_threshhold) * s1));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计逻辑和使用"><a href="#设计逻辑和使用" class="headerlink" title="设计逻辑和使用"></a>设计逻辑和使用</h2><p>BackoffThrottle 希望实现一个对每个请求追加一个动态实延，逐步减缓IO，使IO更平滑<br>避免达到阀值后全部则阻塞，表现就是IO实延波动很大<br>filestore_queue_high_delay_multiple<br>filestore_queue_max_delay_multiple设置为0，也就是比率为0，动态调控是关闭的<br>下面来说一下相关的参数的意义<br>以file的ops为例</p><h3 id="filestore-expected-throughput-ops"><a href="#filestore-expected-throughput-ops" class="headerlink" title="filestore_expected_throughput_ops"></a>filestore_expected_throughput_ops</h3><p>为流控的目标，也就是最终的目标ops</p><h3 id="filestore-queue-max-ops"><a href="#filestore-queue-max-ops" class="headerlink" title="filestore_queue_max_ops"></a>filestore_queue_max_ops</h3><p>流控的上限，最大值，整个流控是按照当前水平/最大值的比率来控制的</p><h3 id="filestore-queue-high-delay-multiple，filestore-queue-low-threshhold-filestore-queue-high-threshhold"><a href="#filestore-queue-high-delay-multiple，filestore-queue-low-threshhold-filestore-queue-high-threshhold" class="headerlink" title="filestore_queue_high_delay_multiple，filestore_queue_low_threshhold,filestore_queue_high_threshhold"></a>filestore_queue_high_delay_multiple，filestore_queue_low_threshhold,filestore_queue_high_threshhold</h3><p>有_get_delay函数可以知道，控制分3个等级，第一级别无控制<br>当current/max &lt; filestore_queue_low_threshhold 无控制<br>filestore_queue_low_threshhold &lt; current/max &lt; filestore_queue_high_threshhold, 第二控制阶段<br>filestore_queue_max_delay_multiple 为降速的倍率<br>举个例子 目标是1w， 平均耗时 1000000us/10000 = 100us<br>如果<br>filestore_queue_high_delay_multiple 2<br>filestore_queue_low_threshhold 0.6<br>filestore_queue_high_threshhold 0.9<br>max      5w<br>expected 1w<br>也就是当io大于3w时,小于4.5w时 每个IO等待0+ms ~ 200us， 随着current的提高逐步到200us</p><h3 id="filestore-queue-max-delay-multiple-同上"><a href="#filestore-queue-max-delay-multiple-同上" class="headerlink" title="filestore_queue_max_delay_multiple 同上"></a>filestore_queue_max_delay_multiple 同上</h3><p>filestore_queue_max_delay_multiple = 10<br>则 大于4.5w时， 每个io等待 200us~1000us</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1 由于get时会加锁，这种模型比较适合单线程模型，一般filestore都是多线程，delay意味着所有线程都有等待，所以时延会成倍增长，如果使用倍率值应该设置的小一些<br>2 这个设计应该是为hdd 等比较慢的介质开发的，ssd的话单filestore这种io模型比较难达到ssd上限<br>3 journal是顺序写，会比filestore快很多无论hdd还是ssd，所以从iops上限制会好很多，但是journal却只有流量限制， 如果使用在journal上加一个ops的限制会使IO平滑许多</p>]]></content>
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
            <tag> osd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ceph源码分析:rbd-nbd</title>
      <link href="/2018/04/16/rbd_nbd_analy/"/>
      <url>/2018/04/16/rbd_nbd_analy/</url>
      <content type="html"><![CDATA[<h2 id="nbd简介"><a href="#nbd简介" class="headerlink" title="nbd简介"></a>nbd简介</h2><p>NBD(Network Block Device)让你可以将一个远程主机的磁盘空间,当作一个块设备来使用.就像一块硬盘一样。<br>NBD是内核模块，大部分linux发行版都已经包含它</p><h2 id="rbd-nbd"><a href="#rbd-nbd" class="headerlink" title="rbd-nbd"></a>rbd-nbd</h2><p>通过nbd librbd来映射一个ceph镜像为本地块设备</p><h2 id="rbd-nbd使用"><a href="#rbd-nbd使用" class="headerlink" title="rbd-nbd使用"></a>rbd-nbd使用</h2><h3 id="查看是否安装nbd驱动"><a href="#查看是否安装nbd驱动" class="headerlink" title="查看是否安装nbd驱动"></a>查看是否安装nbd驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">lsmon | grep nbd</span></span><br><span class="line">nbd                    20480  1</span><br></pre></td></tr></table></figure><p>（如果没有请先下载安装nbd.ko, 一般发行版本都已经默认安装）</p><h3 id="安装rbd-nbd"><a href="#安装rbd-nbd" class="headerlink" title="安装rbd-nbd"></a>安装rbd-nbd</h3><p>如果是自行编译ceph，则选择编译rbd-nbd<br>否侧先查看ceph 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ceph -v</span></span><br><span class="line">ceph version 10.2.7 (50e863e0f4bc8f4b9e31156de690d765af245185)</span><br></pre></td></tr></table></figure><p><a href="https://download.ceph.com/rpm-jewel/el7/x86_64/" target="_blank" rel="noopener">https://download.ceph.com/rpm-jewel/el7/x86_64/</a> 下载对应版本的rbd-nbd 包</p><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">./rbd create image3 -s 10M</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">./rbd list</span></span><br><span class="line">image1</span><br><span class="line">image2</span><br><span class="line">image3</span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">sudo ./rbd-nbd map rbd/image1</span></span><br><span class="line">/dev/nbd0</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码为src/tools/rbd_nbd/rbd-nbd.cc<br>主要有三个命令<br>map              -&gt; do_map<br>                                NBDServer server(fd[1], image);<br>                                ioctl(nbd, NBD_DO_IT);<br>                                server.stop();<br>unmap            -&gt; do_unmap<br>list-mapped      -&gt; do_list_mapped_devices</p><p>主要的工作流程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> r </span>= safe_read_exact(fd, &amp;ctx-&gt;request, <span class="keyword">sizeof</span>(struct nbd_request));        <span class="comment">// 读取命令</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (ctx-&gt;command)&#123;</span><br><span class="line">        <span class="keyword">case</span> NBD_CMD_DISC:</span><br><span class="line">        <span class="keyword">case</span> NBD_CMD_WRITE:               <span class="comment">// 如果是写命令会再读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    io_start(pctx);                       <span class="comment">// 放入队列等待操作完成</span></span><br><span class="line">    <span class="keyword">switch</span> (pctx-&gt;command)&#123;</span><br><span class="line">        开始调用librbd执行io操作</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_entry</span><span class="params">()</span>                       <span class="comment">// 主要是负责发送操作完成的回应</span></span></span><br></pre></td></tr></table></figure></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>现在由于考虑到krbd当前还有一些问题作为替换krbd的一个方案</p><h2 id="其他nbd的使用参考"><a href="#其他nbd的使用参考" class="headerlink" title="其他nbd的使用参考"></a>其他nbd的使用参考</h2><p><a href="https://blog.csdn.net/kenera/article/details/16839499" target="_blank" rel="noopener">https://blog.csdn.net/kenera/article/details/16839499</a><br><a href="https://www.cnblogs.com/doscho/p/7112916.html" target="_blank" rel="noopener">https://www.cnblogs.com/doscho/p/7112916.html</a></p>]]></content>
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
            <tag> nbd </tag>
            
            <tag> rbd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ceph源码分析:ceph 读写流程中的锁 - pg lock</title>
      <link href="/2017/10/04/ceph_lock_pg/"/>
      <url>/2017/10/04/ceph_lock_pg/</url>
      <content type="html"><![CDATA[<h2 id="ceph-读写流程中的锁"><a href="#ceph-读写流程中的锁" class="headerlink" title="ceph 读写流程中的锁"></a>ceph 读写流程中的锁</h2><p>读写流程的锁主要分两种 pg lock 和对象锁<br>pg lock                                  主要维护pg的一致性， 所以恢复，写入等操作会加锁 ，通过控制journal这一层来控制一致性（入队，出对要加锁控制版本的变化）<br>ondisk_read_lock / ondisk_write_lock     用来控制同一对象的读写关系，互斥同一对象的读写, 可以参见–(yu) code rgw 11 其中ObjectContextRef用来描述一个对象，操作时会先获取他的锁 rw_locks</p><h2 id="处理线程"><a href="#处理线程" class="headerlink" title="处理线程"></a>处理线程</h2><p>处理线程是osd_op_tp ，这是一个shardedwq<br>这个线程池的几个主要参数<br>osd_op_num_shards                所有的请求取模分到指定的线程组处理<br>osd_op_num_threads_per_shard    每个线程组中线程数<br>osd_op_thread_timeout           线程处理超时阀值<br>osd_op_thread_suicide_timeout   自杀阀值，超过此值osd自动退出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OSD::OSD(...):</span><br><span class="line">...</span><br><span class="line"><span class="number">1672</span>=&gt;op_shardedwq(</span><br><span class="line"><span class="number">1673</span>    cct-&gt;_conf-&gt;osd_op_num_shards,</span><br><span class="line"><span class="number">1674</span>    <span class="keyword">this</span>,</span><br><span class="line"><span class="number">1675</span>    cct-&gt;_conf-&gt;osd_op_thread_timeout,</span><br><span class="line"><span class="number">1676</span>    cct-&gt;_conf-&gt;osd_op_thread_suicide_timeout,</span><br><span class="line"><span class="number">1677</span>    &amp;osd_op_tp),</span><br><span class="line"><span class="number">1678</span>  peering_wq(</span><br><span class="line"><span class="number">1679</span>    <span class="keyword">this</span>,</span><br><span class="line"><span class="number">1680</span>    cct-&gt;_conf-&gt;osd_op_thread_timeout,</span><br><span class="line"><span class="number">1681</span>    cct-&gt;_conf-&gt;osd_op_thread_suicide_timeout,</span><br><span class="line"><span class="number">1682</span>    &amp;osd_tp),</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="主要处理函数"><a href="#主要处理函数" class="headerlink" title="主要处理函数"></a>主要处理函数</h2><p>ShardedOpWQ的处理函数<br>可以看到pg 的锁的颗粒度还是比较大的，以pg为单位，所有在高速场景增加pg数量也可以有效提高并发<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OSD::ShardedOpWQ::_process(<span class="keyword">uint32_t</span> thread_index, heartbeat_handle_d *hb )</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">8697</span>  <span class="keyword">uint32_t</span> shard_index = thread_index % num_shards;           <span class="comment">//</span></span><br><span class="line"><span class="number">8714</span>  pair&lt;PGRef, PGQueueable&gt; item = sdata-&gt;pqueue-&gt;dequeue();</span><br><span class="line"></span><br><span class="line"><span class="number">8717</span>  ThreadPool::<span class="function">TPHandle <span class="title">tp_handle</span><span class="params">(osd-&gt;cct, hb, timeout_interval,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8718</span>    suicide_interval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">8720</span>  (item.first)-&gt;lock_suspend_timeout(tp_handle);              <span class="comment">// 获取pg lock  －－－ 主要这三类操作 OP(osd-&gt;dequeue_op=&gt;ReplicatedPG::do_op)，snap trim(pg-&gt;snap_trimmer)，scrub(pg-&gt;scrub)， 见下面</span></span><br><span class="line"></span><br><span class="line"><span class="number">8722</span>  boost::optional&lt;PGQueueable&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="number">8730</span>  op = sdata-&gt;pg_for_processing[&amp;*(item.first)].front();</span><br><span class="line"></span><br><span class="line"><span class="number">8758</span>  op-&gt;run(osd, item.first, tp_handle);                        <span class="comment">// 根据op类型调用不同处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="number">8771</span>  (item.first)-&gt;unlock();                                     <span class="comment">// 释放pg lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主要处理三类操作"><a href="#主要处理三类操作" class="headerlink" title="主要处理三类操作"></a>主要处理三类操作</h2><p>PGSnapTrim<br>PGScrub<br>OpRequestRef<br>同时处理三类操作意味着如果pg 在处理snap trim 或者scrub操作时pg 是无法响应请求的<br>同时如果单个pg的处理时间过长也会导致所属组的线程数量变少，相关的pg处理速度<br><strong> 最差情况是同组所有线程都在处理snap trim 和scrub操作导致映射这组上的其他pg读写操作无法处理，这一点值得注意 </strong><br>所以要缩短scrub操作的处理时间和增大间隔，并在业务空闲时段处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">347</span>-<span class="class"><span class="keyword">class</span> <span class="title">PGQueueable</span> &#123;</span></span><br><span class="line"><span class="number">348</span>  -<span class="keyword">typedef</span> boost::variant&lt;</span><br><span class="line"><span class="number">349</span>    OpRequestRef,</span><br><span class="line"><span class="number">350</span>    PGSnapTrim,</span><br><span class="line"><span class="number">351</span>    PGScrub</span><br><span class="line"><span class="number">352</span>    &gt; QVariant;</span><br><span class="line"><span class="number">353</span>  QVariant qvariant;</span><br><span class="line"><span class="number">354</span>  <span class="keyword">int</span> cost;</span><br><span class="line"><span class="number">355</span>  <span class="keyword">unsigned</span> priority;</span><br><span class="line"><span class="number">356</span>  <span class="keyword">utime_t</span> start_time;</span><br><span class="line"><span class="number">357</span>  <span class="keyword">entity_inst_t</span> owner;</span><br><span class="line"><span class="number">358</span>  -<span class="class"><span class="keyword">struct</span> <span class="title">RunVis</span> :</span> <span class="keyword">public</span> boost::static_visitor&lt;&gt; &#123;</span><br><span class="line"><span class="number">359</span>    OSD *osd;</span><br><span class="line"><span class="number">360</span>    PGRef &amp;pg;</span><br><span class="line"><span class="number">361</span>    ThreadPool::TPHandle &amp;handle;</span><br><span class="line"><span class="number">362</span>    -RunVis(OSD *osd, PGRef &amp;pg, ThreadPool::TPHandle &amp;handle)</span><br><span class="line"><span class="number">363</span>      : osd(osd), pg(pg), handle(handle) &#123;&#125;</span><br><span class="line"><span class="number">364</span>    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(OpRequestRef &amp;op)</span></span>;</span><br><span class="line"><span class="number">365</span>    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PGSnapTrim &amp;op)</span></span>;</span><br><span class="line"><span class="number">366</span>    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PGScrub &amp;op)</span></span>;</span><br><span class="line"><span class="number">367</span>  &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p>osd_op_num_shards<br>osd_op_num_threads_per_shard<br>osd_op_thread_timeout<br>osd_op_thread_suicide_timeout</p>]]></content>
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
            <tag> osd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ceph源码分析:bluestore - StupidAllocator</title>
      <link href="/2017/09/23/stupidallocator_analy/"/>
      <url>/2017/09/23/stupidallocator_analy/</url>
      <content type="html"><![CDATA[<h2 id="Allocator-StupidAllocator-简介"><a href="#Allocator-StupidAllocator-简介" class="headerlink" title="Allocator-StupidAllocator 简介"></a>Allocator-StupidAllocator 简介</h2><p>Allocator 主要是用来管理bluestore中空闲空间，处理空闲空间的分配和回收<br>已经分配的空间信息，会以将元数据信息固化在磁盘中，这里bluestore和bluefs不同</p><ul><li>bluestore 记录在rocksdb</li><li>bluefs 是把元数据以日志形式记录在开头<br>主要的管理方式有两种</li><li>StupidAllocator  基于区间树的实现</li><li>BitMapAllocator  基于bitmap<h2 id="StupidAllocator-分析"><a href="#StupidAllocator-分析" class="headerlink" title="StupidAllocator 分析"></a>StupidAllocator 分析</h2>StupidAllocator 不需要设备信息来初始化，后面添加freelist  ， 实现依赖btree_interval_set，此处指分区StupidAllocator</li><li>默认有10个btree_interval_set，分配和释放调动allocate和release</li><li>分配和归还时会根据归还的空间长度计算bin值来决定操作哪一个区间树， 总体是小空间操作0号，长度越大操作树的编号越大<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2></li><li>allocate : want_size (期望大小) alloc_unit (对其大小单位) max_alloc_size (最大连续空间，大于此空间会返回列表) hint (对地址的要求，最好大于此地址) extents (返回)<br>如果want_size &gt; max_alloc_size 会返回几个地址段可以非；连续<br>alloc_unit 对应 cct-&gt;_conf-&gt;bluefs_alloc_size<br>allocate_int want_size(需要空间) alloc_unit(空间单位会和其对齐) hint(空间的下边缘，获得的空间互大于这个地址) offset(返回结果地址) length(返回地址长度)<br>wantsize 和alloc_unit 对齐后计算bin值决定选择哪个区间树（这种策略决定了bin越大的区间树，连续空间越大）<br>1 在&gt;=bin值的free中查找 大于hint的地址区间，看是否足够空闲空间<br>2 在&gt;=bin值的free中查找, 0~hint 的区间是否足够空闲空间<br>3 在&lt;bin值的free中查找 大于hint的地址区间，看是否足够空闲空间<br>4 在&lt;bin值的free中查找, 0~hint 的区间是否足够空闲空间<br>总结：后面的区间会比较倾向于处理大的连续空间放到， 前面的区间倾向处理小额的空间分配和归还，分配和归还都是如此</li><li>release<br>归还释放的空间，更新空闲的总空间<br>_insert_free<br>将空间回收后可能会合并成新的区间， 此时需要在把这个区间放到合适bin的freelist中，保证了bin值小的区间连续段也比较小</li><li>init_rm_free 根据log 重整空闲空间區間樹，在bluefs重新mount，replay原数据日志时会使用</li></ul>]]></content>
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
            <tag> bluestore </tag>
            
            <tag> allocator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ceph源码分析:bluestore - bluefs</title>
      <link href="/2017/09/02/bluefs_analy/"/>
      <url>/2017/09/02/bluefs_analy/</url>
      <content type="html"><![CDATA[<h2 id="bluefs-简介"><a href="#bluefs-简介" class="headerlink" title="bluefs 简介"></a>bluefs 简介</h2><p>bluefs 实现了一个简单的文件系统，只支持追加写，没有实现posix的接口，<br>本身只有一层目录和一层文件的两层结构，为rocksdb 量身定做，符合rocksdb和leveldb的文件结构的数据结构<br>rocksdb的存在在bluestore的架构里用于存储元数据，所以bluefs只能自己 管理元数据<br>具体的方式是开辟专门的空间来记录数据操作日志，恢复时利用日志来构建使用关系，定期压缩日志\</p><h2 id="bluefs-结构"><a href="#bluefs-结构" class="headerlink" title="bluefs 结构"></a>bluefs 结构</h2><p>BlockDevice 用于描述物理设备的读写（hdd ssd 都是KernelDevice）<br>IOContext 用于描述IO方式，此处主要是异步IO（类似libaio）， 需要提交到队列，然后commit，等待返回结果<br>    bluefs 的成员IOContext 主要用于读和super的读（只是作为参数）， super的写是sync写<br>    IOContext    主要用在FileWriter 写时（普通写和操作log写）</p><p>Allocator   用于描述磁盘的空闲空间管理，已经分配的空间会由具体的存储引擎来负责保存元数据<br>    bluestore 会将元数据保存到rockdb<br>    bluefs 将元数据的操作日志保存到磁盘中，重建时需要重新replay日志， 定期compact来减少日志量<br>Allocator 包含两种策略StupidAllocator 和BitMapAllocator<br>    StupidAllocator 基于btree_interval_set 的实现<br>    BitMapAllocator 基于bitmap的实现</p><h2 id="主要接口及读写流程"><a href="#主要接口及读写流程" class="headerlink" title="主要接口及读写流程"></a>主要接口及读写流程</h2><p>BlueFS::<br>add_block_device             // 添加设备<br>add_block_extent             // 添加可用范围<br>mkfs                         // 首次创建时初始化<br>mount                        // 如果非首次，挂载时会读取日志重建freelist<br>mkdir                        // 创建目录，只支持一级目录<br>open_for_write &amp;&amp; BlueFS::FileWriter h     // 写文件需要先获得或创建一个写文件句柄<br>h-&gt;append                                  // 写文件<br>fsync  BlueFS::FileWriter h                // 同步到系统<br>close_writer                               // 关闭句柄<br>open_for_read                              // 获得读句柄<br>read<br>umount</p><p>sync_metadata                              // 同步原数据</p><p>bluefs_compact_log_sync true or false<br>unlink<br>flush_log<br>rmdir<br>flush_log                                  // 下刷元数据<br>compact_log<br>// 压缩日志，些时间长了原数据日志很大影响加载时间和空间<br>引用：<br>Inode索引号0和1，由BlueFS内部使用，并且都用于日志文件。正常情况下，日志文件只使用索引号1，只有在Compact日志时才使用临时的索引号0。日志文件只支持Append操作，时间长了，日志文件会占用较大的磁盘空间，并且Replay日志时间也会变久。实际上，日志文件中有用的数据只有，目录文件的元数据以及目录和文件的对应关系。Compact日志的目是，提取这部分有用数据写入到新磁盘空间，并丢掉原来的日志数据，减少日志文件大小，释放磁盘空间。</p><p>Compact日志时先使用索引号0的新日志文件将有用数据写入到磁盘的新位置，然后用新日志文件的元数据更新超级块（除索引号外），将超级块Flush到磁盘。从目前实现来看，修改超级块是个危险系数很高的操作，一方面是因为超级块的重要程度，如果超级块数据出错所有文件将都无法使用，另一方面似乎没有对超级块做数据保护，只提供CRC检验。不过，正常情况下极少修改超级块的数据，写磁盘时也会绕过本地缓存</p><h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">id 设备MAX_BDEV BDEV_WAL BDEV_DB BDEV_SLOW ， 一共三种设备， MAX_BD_EV 对应上限</span><br><span class="line"><span class="number">244</span>-  <span class="comment">/*</span></span><br><span class="line"><span class="comment">245   * There are up to 3 block devices:</span></span><br><span class="line"><span class="comment">246   *</span></span><br><span class="line"><span class="comment">247   *  BDEV_DB   db/      - the primary db device</span></span><br><span class="line"><span class="comment">248   *  BDEV_WAL  db.wal/  - a small, fast device, specifically for the WAL</span></span><br><span class="line"><span class="comment">249   *  BDEV_SLOW db.slow/ - a big, slow device, to spill over to as BDEV_DB fills</span></span><br><span class="line"><span class="comment">250   */</span></span><br><span class="line"><span class="number">251</span>  <span class="built_in">vector</span>&lt;BlockDevice*&gt; bdev;                  </span><br><span class="line"><span class="comment">///&lt; block devices we can use // 封装了不同设直接备操作(read write)</span></span><br><span class="line"><span class="number">252</span>  <span class="built_in">vector</span>&lt;IOContext*&gt; ioc;                     </span><br><span class="line"><span class="comment">///&lt; IOContexts for bdevs     // IOContext主要封装读写操作模式（libaio directio）</span></span><br><span class="line"><span class="number">253</span>  <span class="built_in">vector</span>&lt;interval_set&lt;<span class="keyword">uint64_t</span>&gt; &gt; block_all;  </span><br><span class="line"><span class="comment">///&lt; extents in bdev we own</span></span><br><span class="line"><span class="number">254</span>  <span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; block_total;               </span><br><span class="line"><span class="comment">///&lt; sum of block_all</span></span><br><span class="line"><span class="number">255</span>  <span class="built_in">vector</span>&lt;Allocator*&gt; alloc;                   </span><br><span class="line"><span class="comment">///&lt; allocators for bdevs     // 介质空闲空间的管理，已分配的空间落盘时会写入元数据</span></span><br></pre></td></tr></table></figure><h2 id="主要流程源码"><a href="#主要流程源码" class="headerlink" title="主要流程源码"></a>主要流程源码</h2><h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">bluefs::open_for_write</span><br><span class="line">    bluefs 只支持一层目录</span><br><span class="line">    dir_map 描述所有目录</span><br><span class="line">    file_map 描述所有文件</span><br><span class="line">    dir-&gt;file_map 描述目录下文件</span><br><span class="line">    File  fnode.ino file_map索引</span><br><span class="line">          fnode.mtime</span><br><span class="line">          fnode.prefer_bdev 优先的介质</span><br><span class="line">          fnode.extents 空间地址</span><br><span class="line">    bluefs_transaction_t log_t 元数据日志，还未写入的</span><br><span class="line">    PerfCounters logger只是计数器，用于操作统计</span><br><span class="line">    BlueFS::FileWriter *BlueFS::_create_writer(FileRef f)</span><br><span class="line">        FileWriter::iocv 通过file创建，为每一个介质，创建IOContext</span><br><span class="line">bluefs::fsync</span><br><span class="line">    =&gt;_flush</span><br><span class="line">        检测数据长度是否满足bluefs_min_flush_size</span><br><span class="line">        =&gt;_flush_range(h, offset, length)</span><br><span class="line">            计算偏移量，调用相应io方式，direct还是libaio，如果libaio再submit，记录pending io数量</span><br><span class="line">            将所有的变动元数据写入dirty_files， 编号写入文件dirty_seq</span><br><span class="line">    =&gt;_flush_bdev_safely</span><br><span class="line">        等待所有aio 完成</span><br><span class="line">    =&gt;_flush_and_sync_log(l, old_dirty_seq)</span><br><span class="line">        将dirty_seq编号的元数据落盘</span><br><span class="line">        =&gt;bluefs_transaction_t log_t.op_file_update(log_writer-&gt;file-&gt;fnode);    </span><br><span class="line">                                                   // 将多有的文件变动写入日志</span><br><span class="line">        =&gt;FileWriter* log_writer-&gt;append(bl);      // 日志编码成buffer， 记入log_write</span><br><span class="line">        =&gt;_flush(log_writer, true);                // 将内容写入磁盘</span><br><span class="line">        =&gt;_flush_bdev_safely(log_writer);          // 确保数据落盘</span><br><span class="line">        更新统计数据</span><br><span class="line"><span class="meta">#</span>## 初始化流程</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">BlueFS::add_block_device        // 记录使用哪个文件（也可以指定块设备）</span><br><span class="line">    BlockDevice *b = BlockDevice::create</span><br><span class="line">        new KernelDevice</span><br><span class="line">    b.open</span><br><span class="line"></span><br><span class="line">BlueFS::fs.add_block_extent    // 划分设备的使用空间</span><br><span class="line">    block_all[id].insert(offset, length)</span><br><span class="line">    block_total[id] += length;</span><br><span class="line">    bluefs_transaction_t log_t.op_alloc_add(id, offset, length);  // 操作日志</span><br><span class="line">    int r = _flush_and_sync_log(l);</span><br><span class="line">    alloc[id]-&gt;init_add_free(offset, length);</span><br><span class="line">        </span><br><span class="line">BlueFS::mkfs    </span><br><span class="line">    _flush_and_sync_log</span><br><span class="line">        _pad_bl                // 对齐super.block_size，补0</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> storage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ceph </tag>
            
            <tag> bluestore </tag>
            
            <tag> bluefs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于hexo+github搭建个人blog</title>
      <link href="/2017/08/11/build_blog_with_hexo/"/>
      <url>/2017/08/11/build_blog_with_hexo/</url>
      <content type="html"><![CDATA[<p>之前大部分工作笔记记录在Eventnote，由于大部分笔记比较杂乱，之后整理了一部分到CSDN，后来看朋友分享的一些blog，觉得模板式样不错。<br>这里是第一篇文章记录下来自己搭建博客的过程和中间遇到的问题<br>后面可能会单独开一篇整理一下搭建过程中遇到的问题和markdown的语法</p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>macos         ok<br>centos 6.5    ok<br>fedore 23     X</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>请参考: <a href="https://hexo.io/zh-cn/docs/#安装" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/#安装</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install npm.x86_64             // 安装nodejs</span><br><span class="line">sudo npm install -g hexo-cli            // </span><br><span class="line">sudo npm install -g hexo</span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h3 id="初始化hexo目录"><a href="#初始化hexo目录" class="headerlink" title="初始化hexo目录"></a>初始化hexo目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init .</span><br></pre></td></tr></table></figure><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><ul><li>_config.yml   网站主要配置项 </li><li>source目录    网站的主要内容，里面_post目录下是所有文章的markdown文件</li><li>themes目录    hexo的模板文件，里面没一个目录都是一个hexo模板，每个模板有自己的配置文件</li><li>package.json  主要是nodejs的依赖，下次构建工作目录时会方便一些</li><li>scaffolds目录 存放模板文件</li></ul><p>还有一个主要的配置文件在模板目录下</p><h3 id="hexo模板"><a href="#hexo模板" class="headerlink" title="hexo模板"></a>hexo模板</h3><p>模板可以从这里挑一个 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>我选的 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a><br>相应的配置说明 <a href="https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md</a><br>把相应的模板拷贝到themes下<br>默认配置文件是next/_config.yml, 可以参考上面的链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"><span class="built_in">cd</span> themes/next &amp;&amp; git checkout v5.1.3 &amp;&amp; <span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></p><h3 id="测试网站"><a href="#测试网站" class="headerlink" title="测试网站"></a>测试网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s </span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>使用本地浏览器访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><h3 id="关联github账号"><a href="#关联github账号" class="headerlink" title="关联github账号"></a>关联github账号</h3><p>在github上创建一个和你名字相同的repository : <your-github-name>.github.io&gt;, 由于github提供二级域名，所以取其他的名字不行<br>关于github账号的申请，免密码登陆可以参考其他文章，此处不再详细介绍<br>编辑hexo的配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:&lt;your-github-name&gt;/&lt;your-github-name&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></your-github-name></p><h3 id="发布博客到github"><a href="#发布博客到github" class="headerlink" title="发布博客到github"></a>发布博客到github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此处我参考了一个脚本，作为发布脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat deploy.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hexo clean Error!"</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hexo generate Error!"</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hexo deploy Error!"</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>之后就可以访问你的博客了&lt;your-github-name.github.io&gt;</p><h3 id="管理博客源文件"><a href="#管理博客源文件" class="headerlink" title="管理博客源文件"></a>管理博客源文件</h3><p>再创建一个repository 来管理你的源文件，方便在其他地方搭建博客的的工作目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tree</span></span><br><span class="line">├── _config.yml</span><br><span class="line">├── deploy.sh</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── package.json</span><br><span class="line">├── db.json</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">│   ├── categories</span><br><span class="line">│   │   └── index.md</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   └── tags</span><br><span class="line">│       └── index.md</span><br><span class="line">└── themes</span><br><span class="line">    └── next</span><br><span class="line">        └── _config.yml</span><br><span class="line"></span><br><span class="line">7 directories, 11 files</span><br></pre></td></tr></table></figure></p><p>主要管理这些配置文件和源文件就可以<br>如果需要在构建博客的工作目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitee.com:simon29/blog.git</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">mv themes/next themes/next_1</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"><span class="built_in">cd</span> themes/next &amp;&amp; git checkout v5.1.3 &amp;&amp; <span class="built_in">cd</span> -</span><br><span class="line">cp themes/next_1/_config.yml themes/next</span><br><span class="line">rm -rf themes/next_1</span><br></pre></td></tr></table></figure></p><h3 id="申请域名与域名绑定"><a href="#申请域名与域名绑定" class="headerlink" title="申请域名与域名绑定"></a>申请域名与域名绑定</h3><p>这个我还没弄;)</p><h2 id="blog优化及遇到的问题"><a href="#blog优化及遇到的问题" class="headerlink" title="blog优化及遇到的问题"></a>blog优化及遇到的问题</h2><ol><li>Hexo之next主题设置首页不显示全文<br>_config.yml开启auto_excerpt项<br>或者<br>用md写的话，在文章里加<a id="more"></a> 会自动截断<br>ref<br><a href="https://www.jianshu.com/p/393d067dba8d" target="_blank" rel="noopener">https://www.jianshu.com/p/393d067dba8d</a></li><li>设置语言<br>在hexo 文件夹里的_config.yml 修改 language: zh-CN</li><li>显示网站统计<br>themes/next/_config.yml<br>开启 busuanzi_count<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2>推荐typora 小巧，跨平台，所见即所得<br>官网 <a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="https://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="noopener">https://www.cnblogs.com/MuYunyun/p/5927491.html</a><br><a href="http://www.yangguanjun.com/2017/05/21/hexo-pagesgithub-build-website/" target="_blank" rel="noopener">http://www.yangguanjun.com/2017/05/21/hexo-pagesgithub-build-website/</a><br><a href="https://github.com/chriskempson/tomorrow-theme" target="_blank" rel="noopener">https://github.com/chriskempson/tomorrow-theme</a><br><a href="https://www.jianshu.com/p/4ef35521fee9" target="_blank" rel="noopener">https://www.jianshu.com/p/4ef35521fee9</a><br><a href="http://blog.csdn.net/superchao_5/article/details/51963942" target="_blank" rel="noopener">http://blog.csdn.net/superchao_5/article/details/51963942</a><br><a href="http://blog.csdn.net/wx_962464/article/details/44786929" target="_blank" rel="noopener">http://blog.csdn.net/wx_962464/article/details/44786929</a></li></ol>]]></content>
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
